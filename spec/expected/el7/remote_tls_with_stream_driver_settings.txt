ruleset(
  name="ruleset_test_name"
  queue.filename="test_name_disk_queue"
  queue.dequeuebatchsize="16"
  queue.lowwatermark="2000"
  queue.discardmark="9750"
  queue.discardseverity="8"
  queue.syncqueuefiles="off"
  queue.type="LinkedList"
  queue.workerthreads="1"
  queue.timeoutshutdown="0"
  queue.timeoutactioncompletion="1000"
  queue.timeoutenqueue="2000"
  queue.timeoutworkerthreadshutdown="60000"
  queue.workerthreadminimummessages="100"
  queue.maxfilesize="1m"
  queue.saveonshutdown="on"
  queue.dequeueslowdown="0"
) {
  action(
    type="omfwd"
    protocol="tcp"
    target="logserver.my.domain"
    port="6514"
    TCP_Framing="traditional"
    ZipLevel="0"
    maxErrorMessages="5"
    compression.mode="none"
    compression.stream.flushOnTXEnd="on"
    StreamDriver="my_stream_driver"
    StreamDriverMode="2"
    StreamDriverAuthMode="my_stream_driver/x509/name"
    StreamDriverPermittedPeers="*.my.domain,*.other.place"
    ResendLastMSGOnReconnect="on"
  )
  action(
    type="omfwd"
    protocol="tcp"
    target="logserver2.other.place"
    port="4444"
    TCP_Framing="traditional"
    ZipLevel="0"
    maxErrorMessages="5"
    compression.mode="none"
    compression.stream.flushOnTXEnd="on"
    StreamDriver="my_stream_driver"
    StreamDriverMode="2"
    StreamDriverAuthMode="my_stream_driver/x509/name"
    StreamDriverPermittedPeers="*.my.domain,*.other.place"
    ResendLastMSGOnReconnect="on"
  )

  action(
    type="omfwd"
    protocol="tcp"
    target="failover.my.domain"
    port="6514"
    TCP_Framing="traditional"
    ZipLevel="0"
    maxErrorMessages="5"
    compression.mode="none"
    compression.stream.flushOnTXEnd="on"
    StreamDriver="my_stream_driver"
    StreamDriverMode="2"
    StreamDriverAuthMode="my_stream_driver/x509/name"
    StreamDriverPermittedPeers="*.my.domain,*.other.place"
    ResendLastMSGOnReconnect="on"
    action.resumeRetryCount="-1"
    action.execOnlyWhenPreviousIsSuspended="on"
  )

  action(
    type="omfwd"
    protocol="tcp"
    target="failover.other.place"
    port="4444"
# NOTE: This must exist for the last failover host so that we can queue logs to disk when needed.
    queue.filename="test_name_disk_queue_action"
    queue.dequeuebatchsize="16"
    queue.lowwatermark="2000"
    queue.discardmark="9750"
    queue.discardseverity="8"
    queue.syncqueuefiles="off"
    queue.type="LinkedList"
    queue.workerthreads="1"
    queue.timeoutshutdown="0"
    queue.timeoutactioncompletion="1000"
    queue.timeoutenqueue="2000"
    queue.timeoutworkerthreadshutdown="60000"
    queue.workerthreadminimummessages="100"
    queue.maxfilesize="1m"
    queue.saveonshutdown="on"
    queue.dequeueslowdown="0"
    TCP_Framing="traditional"
    ZipLevel="0"
    maxErrorMessages="5"
    compression.mode="none"
    compression.stream.flushOnTXEnd="on"
    StreamDriver="my_stream_driver"
    StreamDriverMode="2"
    StreamDriverAuthMode="my_stream_driver/x509/name"
    StreamDriverPermittedPeers="*.my.domain,*.other.place"
    ResendLastMSGOnReconnect="on"
    action.resumeRetryCount="-1"
    action.execOnlyWhenPreviousIsSuspended="on"
  )
}

if (test_rule) then call ruleset_test_name
